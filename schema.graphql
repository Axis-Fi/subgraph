# TODO Split into Atomic and Batch auction lots

### Atomic Auctions

type AtomicAuctionLot @entity {
  id: String! # chain-auctionHouse-lotId
  chain: String!
  auctionHouse: Bytes! # address
  lotId: BigInt!

  createdBlockNumber: BigInt!
  createdBlockTimestamp: BigInt!
  createdDate: String!
  createdTransactionHash: Bytes!

  # Lot details
  capacityInQuote: Boolean!
  capacityInitial: BigDecimal! # uint256
  start: BigInt! # timestamp
  conclusion: BigInt! # timestamp

  # Routing details
  auctionRef: Bytes! # bytes7
  auctionType: String! # bytes7
  baseToken: Token! # address
  quoteToken: Token! # address
  seller: Bytes! # address
  derivativeRef: Bytes! # bytes7
  wrapDerivative: Boolean!

  # TODO consider how to include data from the auction module

  # Fee details
  curator: Bytes! # address
  curatorApproved: Boolean!
  curatorFee: BigDecimal! # uint256
  protocolFee: BigDecimal! # uint256
  referrerFee: BigDecimal! # uint256

  # These values are updated when events occur
  capacity: BigDecimal! # uint256
  sold: BigDecimal! # uint256
  purchased: BigDecimal! # uint256
  lastUpdatedBlockNumber: BigInt!
  lastUpdatedBlockTimestamp: BigInt!
  lastUpdatedDate: String!
  lastUpdatedTransactionHash: Bytes!

  # Reverse lookups
  cancelled: AtomicAuctionCancelled @derivedFrom(field: "lot")
  created: AtomicAuctionCreated! @derivedFrom(field: "lot")
  curated: AtomicAuctionCurated @derivedFrom(field: "lot")
  purchases: [AtomicPurchase!]! @derivedFrom(field: "lot")
}

type AtomicAuctionCreated @entity(immutable: true) {
  id: Bytes!
  lot: AtomicAuctionLot!
  infoHash: String! # IPFS info hash

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  date: String!
  transactionHash: Bytes!
}

type AtomicAuctionCancelled @entity(immutable: true) {
  id: Bytes!
  lot: AtomicAuctionLot!
  auctionRef: Bytes! # bytes7

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  date: String!
  transactionHash: Bytes!
}

type AtomicAuctionCurated @entity(immutable: true) {
  id: Bytes!
  lot: AtomicAuctionLot!
  curator: Bytes! # address

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  date: String!
  transactionHash: Bytes!
}

type AtomicPurchase @entity(immutable: true) {
  id: Bytes!
  lot: AtomicAuctionLot!
  buyer: Bytes! # address
  referrer: Bytes! # address
  amount: BigDecimal! # uint256
  payout: BigDecimal! # uint256

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  date: String!
  transactionHash: Bytes!
}

type AtomicModuleInstalled @entity(immutable: true) {
  id: Bytes!
  auctionHouse: Bytes! # address
  keycode: Bytes! # bytes5
  version: Int! # uint8
  address: Bytes! # address

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  date: String!
  transactionHash: Bytes!
}

type AtomicModuleSunset @entity(immutable: true) {
  id: Bytes!
  auctionHouse: Bytes! # address
  keycode: Bytes! # bytes5

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  date: String!
  transactionHash: Bytes!
}

type AtomicAuctionHouseOwnershipTransferred @entity(immutable: true) {
  id: Bytes!
  auctionHouse: Bytes! # address
  caller: Bytes! # address
  newOwner: Bytes! # address

  blockNumber: BigInt!
  blockTimestamp: BigInt!
  date: String!
  transactionHash: Bytes!
}

### Batch Auctions

# type AuctionLot @entity {
#   id: String! # lotId
#   lotId: BigInt!
#   createdBlockNumber: BigInt!
#   createdBlockTimestamp: BigInt!
#   createdTransactionHash: Bytes!
#   chain: String!

#   # Lot details
#   capacityInQuote: Boolean!
#   capacityInitial: BigDecimal! # uint256
#   start: BigInt! # timestamp
#   conclusion: BigInt! # timestamp
#   # Routing details
#   auctionRef: Bytes! # bytes7
#   auctionType: String! # bytes7
#   baseToken: Token! # address
#   quoteToken: Token! # address
#   owner: Bytes! # address
#   curator: Bytes! # address
#   curatorApproved: Boolean!
#   derivativeRef: Bytes! # bytes7
#   wrapDerivative: Boolean!
#   #reference: Bytes!

#   # These values are updated when events occur
#   capacity: BigDecimal! # uint256
#   sold: BigDecimal! # uint256
#   purchased: BigDecimal! # uint256
#   lastUpdatedBlockNumber: BigInt!
#   lastUpdatedBlockTimestamp: BigInt!
#   lastUpdatedTransactionHash: Bytes!

#   maxBidId: BigInt! # uint96
#   # Reverse lookups
#   cancelled: AuctionCancelled @derivedFrom(field: "lot")
#   created: AuctionCreated! @derivedFrom(field: "lot")
#   curated: Curated @derivedFrom(field: "lot")
#   bids: [Bid!]! @derivedFrom(field: "lot")
#   bidsDecrypted: [BidDecrypted!]! @derivedFrom(field: "lot")
#   purchases: [Purchase!]! @derivedFrom(field: "lot")
#   refundedBids: [RefundBid!]! @derivedFrom(field: "lot")
#   settle: Settle @derivedFrom(field: "lot")
# }

# type AuctionCancelled @entity(immutable: true) {
#   id: Bytes!
#   lot: AuctionLot!
#   auctionRef: Bytes! # bytes7
#   blockNumber: BigInt!
#   blockTimestamp: BigInt!
#   transactionHash: Bytes!
# }

# type AuctionCreated @entity(immutable: true) {
#   id: Bytes!
#   lot: AuctionLot!
#   blockNumber: BigInt!
#   blockTimestamp: BigInt!
#   transactionHash: Bytes!
#   infoHash: String! # IPFS info hash
# }

# type Bid @entity {
#   id: String! # lotId + bidId
#   lot: AuctionLot!
#   bidId: BigInt! # uint96
#   bidder: Bytes! # address
#   amountIn: BigDecimal! # uint256
#   amountOut: BigDecimal # uint256
#   rawAmountIn: BigInt!
#   rawAmountOut: BigInt
#   settledAmountOut: BigDecimal # uint256
#   submittedPrice: BigDecimal
#   rawMarginalPrice: BigInt
#   rawSubmittedPrice: BigInt
#   remainingCapacity: BigDecimal
#   blockNumber: BigInt!
#   blockTimestamp: BigInt!
#   transactionHash: Bytes!
#   status: String! # enum: "submitted" | "decrypted" | "won" | "refunded"
#   # Reverse lookups
#   decrypted: BidDecrypted @derivedFrom(field: "bid")
#   refunded: RefundBid @derivedFrom(field: "bid")
# }

# type RefundBid @entity(immutable: true) {
#   id: Bytes!
#   lot: AuctionLot!
#   bid: Bid!
#   bidder: Bytes! # address
#   blockNumber: BigInt!
#   blockTimestamp: BigInt!
#   transactionHash: Bytes!
# }

# type Curated @entity(immutable: true) {
#   id: Bytes!
#   lot: AuctionLot!
#   curator: Bytes! # address
#   blockNumber: BigInt!
#   blockTimestamp: BigInt!
#   transactionHash: Bytes!
# }

# type Purchase @entity(immutable: true) {
#   id: Bytes!
#   lot: AuctionLot!
#   buyer: Bytes! # address
#   referrer: Bytes! # address
#   amount: BigDecimal! # uint256
#   payout: BigDecimal! # uint256
#   blockNumber: BigInt!
#   blockTimestamp: BigInt!
#   transactionHash: Bytes!
# }

# type Settle @entity(immutable: true) {
#   id: Bytes!
#   lot: AuctionLot!
#   blockNumber: BigInt!
#   blockTimestamp: BigInt!
#   transactionHash: Bytes!
# }

# type BidDecrypted @entity(immutable: true) {
#   id: Bytes!
#   lot: AuctionLot!
#   bid: Bid!
#   amountIn: BigDecimal!
#   amountOut: BigDecimal!
#   blockNumber: BigInt!
#   blockTimestamp: BigInt!
#   transactionHash: Bytes!
# }

# # Administrative events

# type ModuleInstalled @entity(immutable: true) {
#   id: Bytes!
#   keycode: Bytes! # bytes5
#   version: Int! # uint8
#   address: Bytes! # address
#   blockNumber: BigInt!
#   blockTimestamp: BigInt!
#   transactionHash: Bytes!
# }

# type ModuleSunset @entity(immutable: true) {
#   id: Bytes!
#   keycode: Bytes! # bytes5
#   blockNumber: BigInt!
#   blockTimestamp: BigInt!
#   transactionHash: Bytes!
# }

# type OwnershipTransferred @entity(immutable: true) {
#   id: Bytes!
#   caller: Bytes! # address
#   newOwner: Bytes! # address
#   blockNumber: BigInt!
#   blockTimestamp: BigInt!
#   transactionHash: Bytes!
# }

### Shared types

type Token @entity(immutable: true) {
  id: Bytes!
  address: Bytes!
  name: String!
  symbol: String!
  decimals: Int!
  totalSupply: BigInt!
}
