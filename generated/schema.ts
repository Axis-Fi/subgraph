// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  BigDecimal,
  BigInt,
  Bytes,
  Entity,
  store,
  TypedMap,
  Value,
  ValueKind,
} from "@graphprotocol/graph-ts";

export class AtomicAuctionLot extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    const id = this.get("id");
    assert(id != null, "Cannot save AtomicAuctionLot entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AtomicAuctionLot must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicAuctionLot", id.toString(), this);
    }
  }

  static loadInBlock(id: string): AtomicAuctionLot | null {
    return changetype<AtomicAuctionLot | null>(
      store.get_in_block("AtomicAuctionLot", id),
    );
  }

  static load(id: string): AtomicAuctionLot | null {
    return changetype<AtomicAuctionLot | null>(
      store.get("AtomicAuctionLot", id),
    );
  }

  get id(): string {
    const value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get chain(): string {
    const value = this.get("chain");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set chain(value: string) {
    this.set("chain", Value.fromString(value));
  }

  get auctionHouse(): Bytes {
    const value = this.get("auctionHouse");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auctionHouse(value: Bytes) {
    this.set("auctionHouse", Value.fromBytes(value));
  }

  get lotId(): BigInt {
    const value = this.get("lotId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lotId(value: BigInt) {
    this.set("lotId", Value.fromBigInt(value));
  }

  get createdBlockNumber(): BigInt {
    const value = this.get("createdBlockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set createdBlockNumber(value: BigInt) {
    this.set("createdBlockNumber", Value.fromBigInt(value));
  }

  get createdBlockTimestamp(): BigInt {
    const value = this.get("createdBlockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set createdBlockTimestamp(value: BigInt) {
    this.set("createdBlockTimestamp", Value.fromBigInt(value));
  }

  get createdDate(): string {
    const value = this.get("createdDate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set createdDate(value: string) {
    this.set("createdDate", Value.fromString(value));
  }

  get createdTransactionHash(): Bytes {
    const value = this.get("createdTransactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set createdTransactionHash(value: Bytes) {
    this.set("createdTransactionHash", Value.fromBytes(value));
  }

  get capacityInQuote(): boolean {
    const value = this.get("capacityInQuote");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set capacityInQuote(value: boolean) {
    this.set("capacityInQuote", Value.fromBoolean(value));
  }

  get capacityInitial(): BigDecimal {
    const value = this.get("capacityInitial");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set capacityInitial(value: BigDecimal) {
    this.set("capacityInitial", Value.fromBigDecimal(value));
  }

  get start(): BigInt {
    const value = this.get("start");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set start(value: BigInt) {
    this.set("start", Value.fromBigInt(value));
  }

  get conclusion(): BigInt {
    const value = this.get("conclusion");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set conclusion(value: BigInt) {
    this.set("conclusion", Value.fromBigInt(value));
  }

  get auctionRef(): Bytes {
    const value = this.get("auctionRef");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auctionRef(value: Bytes) {
    this.set("auctionRef", Value.fromBytes(value));
  }

  get auctionType(): string {
    const value = this.get("auctionType");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set auctionType(value: string) {
    this.set("auctionType", Value.fromString(value));
  }

  get baseToken(): Bytes {
    const value = this.get("baseToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get quoteToken(): Bytes {
    const value = this.get("quoteToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set quoteToken(value: Bytes) {
    this.set("quoteToken", Value.fromBytes(value));
  }

  get seller(): Bytes {
    const value = this.get("seller");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set seller(value: Bytes) {
    this.set("seller", Value.fromBytes(value));
  }

  get derivativeRef(): Bytes {
    const value = this.get("derivativeRef");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set derivativeRef(value: Bytes) {
    this.set("derivativeRef", Value.fromBytes(value));
  }

  get wrapDerivative(): boolean {
    const value = this.get("wrapDerivative");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set wrapDerivative(value: boolean) {
    this.set("wrapDerivative", Value.fromBoolean(value));
  }

  get curator(): Bytes {
    const value = this.get("curator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set curator(value: Bytes) {
    this.set("curator", Value.fromBytes(value));
  }

  get curatorApproved(): boolean {
    const value = this.get("curatorApproved");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set curatorApproved(value: boolean) {
    this.set("curatorApproved", Value.fromBoolean(value));
  }

  get curatorFee(): BigDecimal {
    const value = this.get("curatorFee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set curatorFee(value: BigDecimal) {
    this.set("curatorFee", Value.fromBigDecimal(value));
  }

  get protocolFee(): BigDecimal {
    const value = this.get("protocolFee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set protocolFee(value: BigDecimal) {
    this.set("protocolFee", Value.fromBigDecimal(value));
  }

  get referrerFee(): BigDecimal {
    const value = this.get("referrerFee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set referrerFee(value: BigDecimal) {
    this.set("referrerFee", Value.fromBigDecimal(value));
  }

  get capacity(): BigDecimal {
    const value = this.get("capacity");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set capacity(value: BigDecimal) {
    this.set("capacity", Value.fromBigDecimal(value));
  }

  get sold(): BigDecimal {
    const value = this.get("sold");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set sold(value: BigDecimal) {
    this.set("sold", Value.fromBigDecimal(value));
  }

  get purchased(): BigDecimal {
    const value = this.get("purchased");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set purchased(value: BigDecimal) {
    this.set("purchased", Value.fromBigDecimal(value));
  }

  get lastUpdatedBlockNumber(): BigInt {
    const value = this.get("lastUpdatedBlockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lastUpdatedBlockNumber(value: BigInt) {
    this.set("lastUpdatedBlockNumber", Value.fromBigInt(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    const value = this.get("lastUpdatedBlockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }

  get lastUpdatedDate(): string {
    const value = this.get("lastUpdatedDate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lastUpdatedDate(value: string) {
    this.set("lastUpdatedDate", Value.fromString(value));
  }

  get lastUpdatedTransactionHash(): Bytes {
    const value = this.get("lastUpdatedTransactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set lastUpdatedTransactionHash(value: Bytes) {
    this.set("lastUpdatedTransactionHash", Value.fromBytes(value));
  }

  get cancelled(): AtomicAuctionCancelledLoader {
    return new AtomicAuctionCancelledLoader(
      "AtomicAuctionLot",
      this.get("id")!.toString(),
      "cancelled",
    );
  }

  get created(): AtomicAuctionCreatedLoader {
    return new AtomicAuctionCreatedLoader(
      "AtomicAuctionLot",
      this.get("id")!.toString(),
      "created",
    );
  }

  get curated(): AtomicAuctionCuratedLoader {
    return new AtomicAuctionCuratedLoader(
      "AtomicAuctionLot",
      this.get("id")!.toString(),
      "curated",
    );
  }

  get purchases(): AtomicPurchaseLoader {
    return new AtomicPurchaseLoader(
      "AtomicAuctionLot",
      this.get("id")!.toString(),
      "purchases",
    );
  }
}

export class AtomicAuctionCreated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    const id = this.get("id");
    assert(id != null, "Cannot save AtomicAuctionCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AtomicAuctionCreated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicAuctionCreated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AtomicAuctionCreated | null {
    return changetype<AtomicAuctionCreated | null>(
      store.get_in_block("AtomicAuctionCreated", id.toHexString()),
    );
  }

  static load(id: Bytes): AtomicAuctionCreated | null {
    return changetype<AtomicAuctionCreated | null>(
      store.get("AtomicAuctionCreated", id.toHexString()),
    );
  }

  get id(): Bytes {
    const value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    const value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get infoHash(): string {
    const value = this.get("infoHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set infoHash(value: string) {
    this.set("infoHash", Value.fromString(value));
  }

  get blockNumber(): BigInt {
    const value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    const value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    const value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    const value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AtomicAuctionCancelled extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    const id = this.get("id");
    assert(
      id != null,
      "Cannot save AtomicAuctionCancelled entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AtomicAuctionCancelled must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicAuctionCancelled", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AtomicAuctionCancelled | null {
    return changetype<AtomicAuctionCancelled | null>(
      store.get_in_block("AtomicAuctionCancelled", id.toHexString()),
    );
  }

  static load(id: Bytes): AtomicAuctionCancelled | null {
    return changetype<AtomicAuctionCancelled | null>(
      store.get("AtomicAuctionCancelled", id.toHexString()),
    );
  }

  get id(): Bytes {
    const value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    const value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get auctionRef(): Bytes {
    const value = this.get("auctionRef");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auctionRef(value: Bytes) {
    this.set("auctionRef", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    const value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    const value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    const value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    const value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AtomicAuctionCurated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    const id = this.get("id");
    assert(id != null, "Cannot save AtomicAuctionCurated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AtomicAuctionCurated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicAuctionCurated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AtomicAuctionCurated | null {
    return changetype<AtomicAuctionCurated | null>(
      store.get_in_block("AtomicAuctionCurated", id.toHexString()),
    );
  }

  static load(id: Bytes): AtomicAuctionCurated | null {
    return changetype<AtomicAuctionCurated | null>(
      store.get("AtomicAuctionCurated", id.toHexString()),
    );
  }

  get id(): Bytes {
    const value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    const value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get curator(): Bytes {
    const value = this.get("curator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set curator(value: Bytes) {
    this.set("curator", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    const value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    const value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    const value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    const value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AtomicPurchase extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    const id = this.get("id");
    assert(id != null, "Cannot save AtomicPurchase entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AtomicPurchase must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicPurchase", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AtomicPurchase | null {
    return changetype<AtomicPurchase | null>(
      store.get_in_block("AtomicPurchase", id.toHexString()),
    );
  }

  static load(id: Bytes): AtomicPurchase | null {
    return changetype<AtomicPurchase | null>(
      store.get("AtomicPurchase", id.toHexString()),
    );
  }

  get id(): Bytes {
    const value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    const value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get buyer(): Bytes {
    const value = this.get("buyer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set buyer(value: Bytes) {
    this.set("buyer", Value.fromBytes(value));
  }

  get referrer(): Bytes {
    const value = this.get("referrer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set referrer(value: Bytes) {
    this.set("referrer", Value.fromBytes(value));
  }

  get amount(): BigDecimal {
    const value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set amount(value: BigDecimal) {
    this.set("amount", Value.fromBigDecimal(value));
  }

  get payout(): BigDecimal {
    const value = this.get("payout");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set payout(value: BigDecimal) {
    this.set("payout", Value.fromBigDecimal(value));
  }

  get blockNumber(): BigInt {
    const value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    const value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    const value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    const value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AtomicModuleInstalled extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    const id = this.get("id");
    assert(
      id != null,
      "Cannot save AtomicModuleInstalled entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AtomicModuleInstalled must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicModuleInstalled", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AtomicModuleInstalled | null {
    return changetype<AtomicModuleInstalled | null>(
      store.get_in_block("AtomicModuleInstalled", id.toHexString()),
    );
  }

  static load(id: Bytes): AtomicModuleInstalled | null {
    return changetype<AtomicModuleInstalled | null>(
      store.get("AtomicModuleInstalled", id.toHexString()),
    );
  }

  get id(): Bytes {
    const value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auctionHouse(): Bytes {
    const value = this.get("auctionHouse");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auctionHouse(value: Bytes) {
    this.set("auctionHouse", Value.fromBytes(value));
  }

  get keycode(): Bytes {
    const value = this.get("keycode");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set keycode(value: Bytes) {
    this.set("keycode", Value.fromBytes(value));
  }

  get version(): i32 {
    const value = this.get("version");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }

  get address(): Bytes {
    const value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    const value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    const value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    const value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    const value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AtomicModuleSunset extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    const id = this.get("id");
    assert(id != null, "Cannot save AtomicModuleSunset entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AtomicModuleSunset must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicModuleSunset", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AtomicModuleSunset | null {
    return changetype<AtomicModuleSunset | null>(
      store.get_in_block("AtomicModuleSunset", id.toHexString()),
    );
  }

  static load(id: Bytes): AtomicModuleSunset | null {
    return changetype<AtomicModuleSunset | null>(
      store.get("AtomicModuleSunset", id.toHexString()),
    );
  }

  get id(): Bytes {
    const value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auctionHouse(): Bytes {
    const value = this.get("auctionHouse");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auctionHouse(value: Bytes) {
    this.set("auctionHouse", Value.fromBytes(value));
  }

  get keycode(): Bytes {
    const value = this.get("keycode");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set keycode(value: Bytes) {
    this.set("keycode", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    const value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    const value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    const value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    const value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AtomicAuctionHouseOwnershipTransferred extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    const id = this.get("id");
    assert(
      id != null,
      "Cannot save AtomicAuctionHouseOwnershipTransferred entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AtomicAuctionHouseOwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set(
        "AtomicAuctionHouseOwnershipTransferred",
        id.toBytes().toHexString(),
        this,
      );
    }
  }

  static loadInBlock(id: Bytes): AtomicAuctionHouseOwnershipTransferred | null {
    return changetype<AtomicAuctionHouseOwnershipTransferred | null>(
      store.get_in_block(
        "AtomicAuctionHouseOwnershipTransferred",
        id.toHexString(),
      ),
    );
  }

  static load(id: Bytes): AtomicAuctionHouseOwnershipTransferred | null {
    return changetype<AtomicAuctionHouseOwnershipTransferred | null>(
      store.get("AtomicAuctionHouseOwnershipTransferred", id.toHexString()),
    );
  }

  get id(): Bytes {
    const value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auctionHouse(): Bytes {
    const value = this.get("auctionHouse");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auctionHouse(value: Bytes) {
    this.set("auctionHouse", Value.fromBytes(value));
  }

  get caller(): Bytes {
    const value = this.get("caller");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set caller(value: Bytes) {
    this.set("caller", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    const value = this.get("newOwner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    const value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    const value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    const value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    const value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class Token extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    const id = this.get("id");
    assert(id != null, "Cannot save Token entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Token must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Token", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Token | null {
    return changetype<Token | null>(
      store.get_in_block("Token", id.toHexString()),
    );
  }

  static load(id: Bytes): Token | null {
    return changetype<Token | null>(store.get("Token", id.toHexString()));
  }

  get id(): Bytes {
    const value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get address(): Bytes {
    const value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get name(): string {
    const value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get symbol(): string {
    const value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get decimals(): i32 {
    const value = this.get("decimals");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set decimals(value: i32) {
    this.set("decimals", Value.fromI32(value));
  }

  get totalSupply(): BigInt {
    const value = this.get("totalSupply");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalSupply(value: BigInt) {
    this.set("totalSupply", Value.fromBigInt(value));
  }
}

export class AtomicAuctionCancelledLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AtomicAuctionCancelled[] {
    const value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AtomicAuctionCancelled[]>(value);
  }
}

export class AtomicAuctionCreatedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AtomicAuctionCreated[] {
    const value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AtomicAuctionCreated[]>(value);
  }
}

export class AtomicAuctionCuratedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AtomicAuctionCurated[] {
    const value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AtomicAuctionCurated[]>(value);
  }
}

export class AtomicPurchaseLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AtomicPurchase[] {
    const value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AtomicPurchase[]>(value);
  }
}
