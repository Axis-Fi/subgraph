// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal,
} from "@graphprotocol/graph-ts";

export class AtomicAuctionLot extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AtomicAuctionLot entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type AtomicAuctionLot must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicAuctionLot", id.toString(), this);
    }
  }

  static loadInBlock(id: string): AtomicAuctionLot | null {
    return changetype<AtomicAuctionLot | null>(
      store.get_in_block("AtomicAuctionLot", id),
    );
  }

  static load(id: string): AtomicAuctionLot | null {
    return changetype<AtomicAuctionLot | null>(
      store.get("AtomicAuctionLot", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get chain(): string {
    let value = this.get("chain");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set chain(value: string) {
    this.set("chain", Value.fromString(value));
  }

  get auctionHouse(): Bytes {
    let value = this.get("auctionHouse");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auctionHouse(value: Bytes) {
    this.set("auctionHouse", Value.fromBytes(value));
  }

  get lotId(): BigInt {
    let value = this.get("lotId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lotId(value: BigInt) {
    this.set("lotId", Value.fromBigInt(value));
  }

  get createdBlockNumber(): BigInt {
    let value = this.get("createdBlockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set createdBlockNumber(value: BigInt) {
    this.set("createdBlockNumber", Value.fromBigInt(value));
  }

  get createdBlockTimestamp(): BigInt {
    let value = this.get("createdBlockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set createdBlockTimestamp(value: BigInt) {
    this.set("createdBlockTimestamp", Value.fromBigInt(value));
  }

  get createdDate(): string {
    let value = this.get("createdDate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set createdDate(value: string) {
    this.set("createdDate", Value.fromString(value));
  }

  get createdTransactionHash(): Bytes {
    let value = this.get("createdTransactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set createdTransactionHash(value: Bytes) {
    this.set("createdTransactionHash", Value.fromBytes(value));
  }

  get capacityInQuote(): boolean {
    let value = this.get("capacityInQuote");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set capacityInQuote(value: boolean) {
    this.set("capacityInQuote", Value.fromBoolean(value));
  }

  get capacityInitial(): BigDecimal {
    let value = this.get("capacityInitial");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set capacityInitial(value: BigDecimal) {
    this.set("capacityInitial", Value.fromBigDecimal(value));
  }

  get start(): BigInt {
    let value = this.get("start");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set start(value: BigInt) {
    this.set("start", Value.fromBigInt(value));
  }

  get conclusion(): BigInt {
    let value = this.get("conclusion");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set conclusion(value: BigInt) {
    this.set("conclusion", Value.fromBigInt(value));
  }

  get auctionType(): string {
    let value = this.get("auctionType");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set auctionType(value: string) {
    this.set("auctionType", Value.fromString(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get quoteToken(): Bytes {
    let value = this.get("quoteToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set quoteToken(value: Bytes) {
    this.set("quoteToken", Value.fromBytes(value));
  }

  get seller(): Bytes {
    let value = this.get("seller");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set seller(value: Bytes) {
    this.set("seller", Value.fromBytes(value));
  }

  get derivativeType(): string | null {
    let value = this.get("derivativeType");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set derivativeType(value: string | null) {
    if (!value) {
      this.unset("derivativeType");
    } else {
      this.set("derivativeType", Value.fromString(<string>value));
    }
  }

  get wrapDerivative(): boolean {
    let value = this.get("wrapDerivative");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set wrapDerivative(value: boolean) {
    this.set("wrapDerivative", Value.fromBoolean(value));
  }

  get curator(): Bytes | null {
    let value = this.get("curator");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set curator(value: Bytes | null) {
    if (!value) {
      this.unset("curator");
    } else {
      this.set("curator", Value.fromBytes(<Bytes>value));
    }
  }

  get curatorApproved(): boolean {
    let value = this.get("curatorApproved");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set curatorApproved(value: boolean) {
    this.set("curatorApproved", Value.fromBoolean(value));
  }

  get curatorFee(): BigDecimal {
    let value = this.get("curatorFee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set curatorFee(value: BigDecimal) {
    this.set("curatorFee", Value.fromBigDecimal(value));
  }

  get protocolFee(): BigDecimal {
    let value = this.get("protocolFee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set protocolFee(value: BigDecimal) {
    this.set("protocolFee", Value.fromBigDecimal(value));
  }

  get referrerFee(): BigDecimal {
    let value = this.get("referrerFee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set referrerFee(value: BigDecimal) {
    this.set("referrerFee", Value.fromBigDecimal(value));
  }

  get capacity(): BigDecimal {
    let value = this.get("capacity");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set capacity(value: BigDecimal) {
    this.set("capacity", Value.fromBigDecimal(value));
  }

  get sold(): BigDecimal {
    let value = this.get("sold");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set sold(value: BigDecimal) {
    this.set("sold", Value.fromBigDecimal(value));
  }

  get purchased(): BigDecimal {
    let value = this.get("purchased");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set purchased(value: BigDecimal) {
    this.set("purchased", Value.fromBigDecimal(value));
  }

  get lastUpdatedBlockNumber(): BigInt {
    let value = this.get("lastUpdatedBlockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lastUpdatedBlockNumber(value: BigInt) {
    this.set("lastUpdatedBlockNumber", Value.fromBigInt(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }

  get lastUpdatedDate(): string {
    let value = this.get("lastUpdatedDate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lastUpdatedDate(value: string) {
    this.set("lastUpdatedDate", Value.fromString(value));
  }

  get lastUpdatedTransactionHash(): Bytes {
    let value = this.get("lastUpdatedTransactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set lastUpdatedTransactionHash(value: Bytes) {
    this.set("lastUpdatedTransactionHash", Value.fromBytes(value));
  }

  get cancelled(): AtomicAuctionCancelledLoader {
    return new AtomicAuctionCancelledLoader(
      "AtomicAuctionLot",
      this.get("id")!.toString(),
      "cancelled",
    );
  }

  get created(): AtomicAuctionCreatedLoader {
    return new AtomicAuctionCreatedLoader(
      "AtomicAuctionLot",
      this.get("id")!.toString(),
      "created",
    );
  }

  get curated(): AtomicAuctionCuratedLoader {
    return new AtomicAuctionCuratedLoader(
      "AtomicAuctionLot",
      this.get("id")!.toString(),
      "curated",
    );
  }

  get purchases(): AtomicPurchaseLoader {
    return new AtomicPurchaseLoader(
      "AtomicAuctionLot",
      this.get("id")!.toString(),
      "purchases",
    );
  }

  get fixedPriceSale(): AtomicFixedPriceSaleLotLoader {
    return new AtomicFixedPriceSaleLotLoader(
      "AtomicAuctionLot",
      this.get("id")!.toString(),
      "fixedPriceSale",
    );
  }

  get linearVesting(): AtomicLinearVestingLotLoader {
    return new AtomicLinearVestingLotLoader(
      "AtomicAuctionLot",
      this.get("id")!.toString(),
      "linearVesting",
    );
  }
}

export class AtomicAuctionCreated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AtomicAuctionCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AtomicAuctionCreated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicAuctionCreated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AtomicAuctionCreated | null {
    return changetype<AtomicAuctionCreated | null>(
      store.get_in_block("AtomicAuctionCreated", id.toHexString()),
    );
  }

  static load(id: Bytes): AtomicAuctionCreated | null {
    return changetype<AtomicAuctionCreated | null>(
      store.get("AtomicAuctionCreated", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get infoHash(): string {
    let value = this.get("infoHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set infoHash(value: string) {
    this.set("infoHash", Value.fromString(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AtomicAuctionCancelled extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AtomicAuctionCancelled entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AtomicAuctionCancelled must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicAuctionCancelled", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AtomicAuctionCancelled | null {
    return changetype<AtomicAuctionCancelled | null>(
      store.get_in_block("AtomicAuctionCancelled", id.toHexString()),
    );
  }

  static load(id: Bytes): AtomicAuctionCancelled | null {
    return changetype<AtomicAuctionCancelled | null>(
      store.get("AtomicAuctionCancelled", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get auctionRef(): Bytes {
    let value = this.get("auctionRef");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auctionRef(value: Bytes) {
    this.set("auctionRef", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AtomicAuctionCurated extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AtomicAuctionCurated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AtomicAuctionCurated must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicAuctionCurated", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AtomicAuctionCurated | null {
    return changetype<AtomicAuctionCurated | null>(
      store.get_in_block("AtomicAuctionCurated", id.toHexString()),
    );
  }

  static load(id: Bytes): AtomicAuctionCurated | null {
    return changetype<AtomicAuctionCurated | null>(
      store.get("AtomicAuctionCurated", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get curator(): Bytes {
    let value = this.get("curator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set curator(value: Bytes) {
    this.set("curator", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AtomicPurchase extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save AtomicPurchase entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AtomicPurchase must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicPurchase", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AtomicPurchase | null {
    return changetype<AtomicPurchase | null>(
      store.get_in_block("AtomicPurchase", id.toHexString()),
    );
  }

  static load(id: Bytes): AtomicPurchase | null {
    return changetype<AtomicPurchase | null>(
      store.get("AtomicPurchase", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get buyer(): Bytes {
    let value = this.get("buyer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set buyer(value: Bytes) {
    this.set("buyer", Value.fromBytes(value));
  }

  get referrer(): Bytes {
    let value = this.get("referrer");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set referrer(value: Bytes) {
    this.set("referrer", Value.fromBytes(value));
  }

  get amount(): BigDecimal {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set amount(value: BigDecimal) {
    this.set("amount", Value.fromBigDecimal(value));
  }

  get payout(): BigDecimal {
    let value = this.get("payout");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set payout(value: BigDecimal) {
    this.set("payout", Value.fromBigDecimal(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AtomicFixedPriceSaleLot extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AtomicFixedPriceSaleLot entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AtomicFixedPriceSaleLot must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicFixedPriceSaleLot", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AtomicFixedPriceSaleLot | null {
    return changetype<AtomicFixedPriceSaleLot | null>(
      store.get_in_block("AtomicFixedPriceSaleLot", id.toHexString()),
    );
  }

  static load(id: Bytes): AtomicFixedPriceSaleLot | null {
    return changetype<AtomicFixedPriceSaleLot | null>(
      store.get("AtomicFixedPriceSaleLot", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get price(): BigDecimal {
    let value = this.get("price");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set price(value: BigDecimal) {
    this.set("price", Value.fromBigDecimal(value));
  }

  get maxPayout(): BigDecimal {
    let value = this.get("maxPayout");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set maxPayout(value: BigDecimal) {
    this.set("maxPayout", Value.fromBigDecimal(value));
  }
}

export class AtomicLinearVestingLot extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AtomicLinearVestingLot entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AtomicLinearVestingLot must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AtomicLinearVestingLot", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AtomicLinearVestingLot | null {
    return changetype<AtomicLinearVestingLot | null>(
      store.get_in_block("AtomicLinearVestingLot", id.toHexString()),
    );
  }

  static load(id: Bytes): AtomicLinearVestingLot | null {
    return changetype<AtomicLinearVestingLot | null>(
      store.get("AtomicLinearVestingLot", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get startTimestamp(): BigInt {
    let value = this.get("startTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set startTimestamp(value: BigInt) {
    this.set("startTimestamp", Value.fromBigInt(value));
  }

  get startDate(): string {
    let value = this.get("startDate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set startDate(value: string) {
    this.set("startDate", Value.fromString(value));
  }

  get expiryTimestamp(): BigInt {
    let value = this.get("expiryTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set expiryTimestamp(value: BigInt) {
    this.set("expiryTimestamp", Value.fromBigInt(value));
  }

  get expiryDate(): string {
    let value = this.get("expiryDate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set expiryDate(value: string) {
    this.set("expiryDate", Value.fromString(value));
  }
}

export class BatchAuctionLot extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BatchAuctionLot entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BatchAuctionLot must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BatchAuctionLot", id.toString(), this);
    }
  }

  static loadInBlock(id: string): BatchAuctionLot | null {
    return changetype<BatchAuctionLot | null>(
      store.get_in_block("BatchAuctionLot", id),
    );
  }

  static load(id: string): BatchAuctionLot | null {
    return changetype<BatchAuctionLot | null>(store.get("BatchAuctionLot", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get chain(): string {
    let value = this.get("chain");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set chain(value: string) {
    this.set("chain", Value.fromString(value));
  }

  get auctionHouse(): Bytes {
    let value = this.get("auctionHouse");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auctionHouse(value: Bytes) {
    this.set("auctionHouse", Value.fromBytes(value));
  }

  get lotId(): BigInt {
    let value = this.get("lotId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lotId(value: BigInt) {
    this.set("lotId", Value.fromBigInt(value));
  }

  get createdBlockNumber(): BigInt {
    let value = this.get("createdBlockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set createdBlockNumber(value: BigInt) {
    this.set("createdBlockNumber", Value.fromBigInt(value));
  }

  get createdBlockTimestamp(): BigInt {
    let value = this.get("createdBlockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set createdBlockTimestamp(value: BigInt) {
    this.set("createdBlockTimestamp", Value.fromBigInt(value));
  }

  get createdDate(): string {
    let value = this.get("createdDate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set createdDate(value: string) {
    this.set("createdDate", Value.fromString(value));
  }

  get createdTransactionHash(): Bytes {
    let value = this.get("createdTransactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set createdTransactionHash(value: Bytes) {
    this.set("createdTransactionHash", Value.fromBytes(value));
  }

  get capacityInitial(): BigDecimal {
    let value = this.get("capacityInitial");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set capacityInitial(value: BigDecimal) {
    this.set("capacityInitial", Value.fromBigDecimal(value));
  }

  get start(): BigInt {
    let value = this.get("start");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set start(value: BigInt) {
    this.set("start", Value.fromBigInt(value));
  }

  get conclusion(): BigInt {
    let value = this.get("conclusion");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set conclusion(value: BigInt) {
    this.set("conclusion", Value.fromBigInt(value));
  }

  get auctionType(): string {
    let value = this.get("auctionType");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set auctionType(value: string) {
    this.set("auctionType", Value.fromString(value));
  }

  get baseToken(): Bytes {
    let value = this.get("baseToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set baseToken(value: Bytes) {
    this.set("baseToken", Value.fromBytes(value));
  }

  get quoteToken(): Bytes {
    let value = this.get("quoteToken");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set quoteToken(value: Bytes) {
    this.set("quoteToken", Value.fromBytes(value));
  }

  get seller(): Bytes {
    let value = this.get("seller");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set seller(value: Bytes) {
    this.set("seller", Value.fromBytes(value));
  }

  get derivativeType(): string | null {
    let value = this.get("derivativeType");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set derivativeType(value: string | null) {
    if (!value) {
      this.unset("derivativeType");
    } else {
      this.set("derivativeType", Value.fromString(<string>value));
    }
  }

  get wrapDerivative(): boolean {
    let value = this.get("wrapDerivative");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set wrapDerivative(value: boolean) {
    this.set("wrapDerivative", Value.fromBoolean(value));
  }

  get curator(): Bytes | null {
    let value = this.get("curator");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set curator(value: Bytes | null) {
    if (!value) {
      this.unset("curator");
    } else {
      this.set("curator", Value.fromBytes(<Bytes>value));
    }
  }

  get curatorApproved(): boolean {
    let value = this.get("curatorApproved");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set curatorApproved(value: boolean) {
    this.set("curatorApproved", Value.fromBoolean(value));
  }

  get curatorFee(): BigDecimal {
    let value = this.get("curatorFee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set curatorFee(value: BigDecimal) {
    this.set("curatorFee", Value.fromBigDecimal(value));
  }

  get protocolFee(): BigDecimal {
    let value = this.get("protocolFee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set protocolFee(value: BigDecimal) {
    this.set("protocolFee", Value.fromBigDecimal(value));
  }

  get referrerFee(): BigDecimal {
    let value = this.get("referrerFee");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set referrerFee(value: BigDecimal) {
    this.set("referrerFee", Value.fromBigDecimal(value));
  }

  get capacity(): BigDecimal {
    let value = this.get("capacity");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set capacity(value: BigDecimal) {
    this.set("capacity", Value.fromBigDecimal(value));
  }

  get sold(): BigDecimal {
    let value = this.get("sold");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set sold(value: BigDecimal) {
    this.set("sold", Value.fromBigDecimal(value));
  }

  get purchased(): BigDecimal {
    let value = this.get("purchased");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set purchased(value: BigDecimal) {
    this.set("purchased", Value.fromBigDecimal(value));
  }

  get lastUpdatedBlockNumber(): BigInt {
    let value = this.get("lastUpdatedBlockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lastUpdatedBlockNumber(value: BigInt) {
    this.set("lastUpdatedBlockNumber", Value.fromBigInt(value));
  }

  get lastUpdatedBlockTimestamp(): BigInt {
    let value = this.get("lastUpdatedBlockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set lastUpdatedBlockTimestamp(value: BigInt) {
    this.set("lastUpdatedBlockTimestamp", Value.fromBigInt(value));
  }

  get lastUpdatedDate(): string {
    let value = this.get("lastUpdatedDate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lastUpdatedDate(value: string) {
    this.set("lastUpdatedDate", Value.fromString(value));
  }

  get lastUpdatedTransactionHash(): Bytes {
    let value = this.get("lastUpdatedTransactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set lastUpdatedTransactionHash(value: Bytes) {
    this.set("lastUpdatedTransactionHash", Value.fromBytes(value));
  }

  get maxBidId(): BigInt {
    let value = this.get("maxBidId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set maxBidId(value: BigInt) {
    this.set("maxBidId", Value.fromBigInt(value));
  }

  get cancelled(): BatchAuctionCancelledLoader {
    return new BatchAuctionCancelledLoader(
      "BatchAuctionLot",
      this.get("id")!.toString(),
      "cancelled",
    );
  }

  get created(): BatchAuctionCreatedLoader {
    return new BatchAuctionCreatedLoader(
      "BatchAuctionLot",
      this.get("id")!.toString(),
      "created",
    );
  }

  get curated(): BatchAuctionCuratedLoader {
    return new BatchAuctionCuratedLoader(
      "BatchAuctionLot",
      this.get("id")!.toString(),
      "curated",
    );
  }

  get settled(): BatchAuctionSettledLoader {
    return new BatchAuctionSettledLoader(
      "BatchAuctionLot",
      this.get("id")!.toString(),
      "settled",
    );
  }

  get aborted(): BatchAuctionAbortedLoader {
    return new BatchAuctionAbortedLoader(
      "BatchAuctionLot",
      this.get("id")!.toString(),
      "aborted",
    );
  }

  get bids(): BatchBidLoader {
    return new BatchBidLoader(
      "BatchAuctionLot",
      this.get("id")!.toString(),
      "bids",
    );
  }

  get bidsDecrypted(): BatchBidDecryptedLoader {
    return new BatchBidDecryptedLoader(
      "BatchAuctionLot",
      this.get("id")!.toString(),
      "bidsDecrypted",
    );
  }

  get bidsClaimed(): BatchBidClaimedLoader {
    return new BatchBidClaimedLoader(
      "BatchAuctionLot",
      this.get("id")!.toString(),
      "bidsClaimed",
    );
  }

  get bidsRefunded(): BatchBidRefundedLoader {
    return new BatchBidRefundedLoader(
      "BatchAuctionLot",
      this.get("id")!.toString(),
      "bidsRefunded",
    );
  }

  get encryptedMarginalPrice(): BatchEncryptedMarginalPriceLotLoader {
    return new BatchEncryptedMarginalPriceLotLoader(
      "BatchAuctionLot",
      this.get("id")!.toString(),
      "encryptedMarginalPrice",
    );
  }

  get linearVesting(): BatchLinearVestingLotLoader {
    return new BatchLinearVestingLotLoader(
      "BatchAuctionLot",
      this.get("id")!.toString(),
      "linearVesting",
    );
  }
}

export class BatchAuctionCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BatchAuctionCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BatchAuctionCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BatchAuctionCreated", id.toString(), this);
    }
  }

  static loadInBlock(id: string): BatchAuctionCreated | null {
    return changetype<BatchAuctionCreated | null>(
      store.get_in_block("BatchAuctionCreated", id),
    );
  }

  static load(id: string): BatchAuctionCreated | null {
    return changetype<BatchAuctionCreated | null>(
      store.get("BatchAuctionCreated", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get infoHash(): string {
    let value = this.get("infoHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set infoHash(value: string) {
    this.set("infoHash", Value.fromString(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class BatchAuctionCancelled extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save BatchAuctionCancelled entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BatchAuctionCancelled must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BatchAuctionCancelled", id.toString(), this);
    }
  }

  static loadInBlock(id: string): BatchAuctionCancelled | null {
    return changetype<BatchAuctionCancelled | null>(
      store.get_in_block("BatchAuctionCancelled", id),
    );
  }

  static load(id: string): BatchAuctionCancelled | null {
    return changetype<BatchAuctionCancelled | null>(
      store.get("BatchAuctionCancelled", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get auctionRef(): Bytes {
    let value = this.get("auctionRef");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auctionRef(value: Bytes) {
    this.set("auctionRef", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class BatchAuctionCurated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BatchAuctionCurated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BatchAuctionCurated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BatchAuctionCurated", id.toString(), this);
    }
  }

  static loadInBlock(id: string): BatchAuctionCurated | null {
    return changetype<BatchAuctionCurated | null>(
      store.get_in_block("BatchAuctionCurated", id),
    );
  }

  static load(id: string): BatchAuctionCurated | null {
    return changetype<BatchAuctionCurated | null>(
      store.get("BatchAuctionCurated", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get curator(): Bytes {
    let value = this.get("curator");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set curator(value: Bytes) {
    this.set("curator", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class BatchAuctionSettled extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BatchAuctionSettled entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BatchAuctionSettled must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BatchAuctionSettled", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): BatchAuctionSettled | null {
    return changetype<BatchAuctionSettled | null>(
      store.get_in_block("BatchAuctionSettled", id.toHexString()),
    );
  }

  static load(id: Bytes): BatchAuctionSettled | null {
    return changetype<BatchAuctionSettled | null>(
      store.get("BatchAuctionSettled", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class BatchAuctionAborted extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BatchAuctionAborted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BatchAuctionAborted must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BatchAuctionAborted", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): BatchAuctionAborted | null {
    return changetype<BatchAuctionAborted | null>(
      store.get_in_block("BatchAuctionAborted", id.toHexString()),
    );
  }

  static load(id: Bytes): BatchAuctionAborted | null {
    return changetype<BatchAuctionAborted | null>(
      store.get("BatchAuctionAborted", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class BatchBid extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BatchBid entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BatchBid must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BatchBid", id.toString(), this);
    }
  }

  static loadInBlock(id: string): BatchBid | null {
    return changetype<BatchBid | null>(store.get_in_block("BatchBid", id));
  }

  static load(id: string): BatchBid | null {
    return changetype<BatchBid | null>(store.get("BatchBid", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get bidId(): BigInt {
    let value = this.get("bidId");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set bidId(value: BigInt) {
    this.set("bidId", Value.fromBigInt(value));
  }

  get bidder(): Bytes {
    let value = this.get("bidder");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set bidder(value: Bytes) {
    this.set("bidder", Value.fromBytes(value));
  }

  get amountIn(): BigDecimal {
    let value = this.get("amountIn");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set amountIn(value: BigDecimal) {
    this.set("amountIn", Value.fromBigDecimal(value));
  }

  get amountOut(): BigDecimal | null {
    let value = this.get("amountOut");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set amountOut(value: BigDecimal | null) {
    if (!value) {
      this.unset("amountOut");
    } else {
      this.set("amountOut", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get rawAmountIn(): BigInt {
    let value = this.get("rawAmountIn");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set rawAmountIn(value: BigInt) {
    this.set("rawAmountIn", Value.fromBigInt(value));
  }

  get rawAmountOut(): BigInt | null {
    let value = this.get("rawAmountOut");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set rawAmountOut(value: BigInt | null) {
    if (!value) {
      this.unset("rawAmountOut");
    } else {
      this.set("rawAmountOut", Value.fromBigInt(<BigInt>value));
    }
  }

  get settledAmountIn(): BigDecimal | null {
    let value = this.get("settledAmountIn");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set settledAmountIn(value: BigDecimal | null) {
    if (!value) {
      this.unset("settledAmountIn");
    } else {
      this.set("settledAmountIn", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get settledAmountInRefunded(): BigDecimal | null {
    let value = this.get("settledAmountInRefunded");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set settledAmountInRefunded(value: BigDecimal | null) {
    if (!value) {
      this.unset("settledAmountInRefunded");
    } else {
      this.set(
        "settledAmountInRefunded",
        Value.fromBigDecimal(<BigDecimal>value),
      );
    }
  }

  get settledAmountOut(): BigDecimal | null {
    let value = this.get("settledAmountOut");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set settledAmountOut(value: BigDecimal | null) {
    if (!value) {
      this.unset("settledAmountOut");
    } else {
      this.set("settledAmountOut", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get submittedPrice(): BigDecimal | null {
    let value = this.get("submittedPrice");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set submittedPrice(value: BigDecimal | null) {
    if (!value) {
      this.unset("submittedPrice");
    } else {
      this.set("submittedPrice", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get rawMarginalPrice(): BigInt | null {
    let value = this.get("rawMarginalPrice");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set rawMarginalPrice(value: BigInt | null) {
    if (!value) {
      this.unset("rawMarginalPrice");
    } else {
      this.set("rawMarginalPrice", Value.fromBigInt(<BigInt>value));
    }
  }

  get rawSubmittedPrice(): BigInt | null {
    let value = this.get("rawSubmittedPrice");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set rawSubmittedPrice(value: BigInt | null) {
    if (!value) {
      this.unset("rawSubmittedPrice");
    } else {
      this.set("rawSubmittedPrice", Value.fromBigInt(<BigInt>value));
    }
  }

  get remainingCapacity(): BigDecimal | null {
    let value = this.get("remainingCapacity");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set remainingCapacity(value: BigDecimal | null) {
    if (!value) {
      this.unset("remainingCapacity");
    } else {
      this.set("remainingCapacity", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get status(): string {
    let value = this.get("status");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set status(value: string) {
    this.set("status", Value.fromString(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }

  get decrypted(): BatchBidDecryptedLoader {
    return new BatchBidDecryptedLoader(
      "BatchBid",
      this.get("id")!.toString(),
      "decrypted",
    );
  }

  get refunded(): BatchBidRefundedLoader {
    return new BatchBidRefundedLoader(
      "BatchBid",
      this.get("id")!.toString(),
      "refunded",
    );
  }

  get claimed(): BatchBidClaimedLoader {
    return new BatchBidClaimedLoader(
      "BatchBid",
      this.get("id")!.toString(),
      "claimed",
    );
  }
}

export class BatchBidRefunded extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BatchBidRefunded entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BatchBidRefunded must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BatchBidRefunded", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): BatchBidRefunded | null {
    return changetype<BatchBidRefunded | null>(
      store.get_in_block("BatchBidRefunded", id.toHexString()),
    );
  }

  static load(id: Bytes): BatchBidRefunded | null {
    return changetype<BatchBidRefunded | null>(
      store.get("BatchBidRefunded", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get bid(): string {
    let value = this.get("bid");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set bid(value: string) {
    this.set("bid", Value.fromString(value));
  }

  get bidder(): Bytes {
    let value = this.get("bidder");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set bidder(value: Bytes) {
    this.set("bidder", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class BatchBidDecrypted extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BatchBidDecrypted entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BatchBidDecrypted must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BatchBidDecrypted", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): BatchBidDecrypted | null {
    return changetype<BatchBidDecrypted | null>(
      store.get_in_block("BatchBidDecrypted", id.toHexString()),
    );
  }

  static load(id: Bytes): BatchBidDecrypted | null {
    return changetype<BatchBidDecrypted | null>(
      store.get("BatchBidDecrypted", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get bid(): string {
    let value = this.get("bid");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set bid(value: string) {
    this.set("bid", Value.fromString(value));
  }

  get amountIn(): BigDecimal {
    let value = this.get("amountIn");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set amountIn(value: BigDecimal) {
    this.set("amountIn", Value.fromBigDecimal(value));
  }

  get amountOut(): BigDecimal {
    let value = this.get("amountOut");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set amountOut(value: BigDecimal) {
    this.set("amountOut", Value.fromBigDecimal(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class BatchBidClaimed extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save BatchBidClaimed entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BatchBidClaimed must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BatchBidClaimed", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): BatchBidClaimed | null {
    return changetype<BatchBidClaimed | null>(
      store.get_in_block("BatchBidClaimed", id.toHexString()),
    );
  }

  static load(id: Bytes): BatchBidClaimed | null {
    return changetype<BatchBidClaimed | null>(
      store.get("BatchBidClaimed", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get bid(): string {
    let value = this.get("bid");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set bid(value: string) {
    this.set("bid", Value.fromString(value));
  }

  get bidder(): Bytes {
    let value = this.get("bidder");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set bidder(value: Bytes) {
    this.set("bidder", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class BatchEncryptedMarginalPriceLot extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save BatchEncryptedMarginalPriceLot entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type BatchEncryptedMarginalPriceLot must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BatchEncryptedMarginalPriceLot", id.toString(), this);
    }
  }

  static loadInBlock(id: string): BatchEncryptedMarginalPriceLot | null {
    return changetype<BatchEncryptedMarginalPriceLot | null>(
      store.get_in_block("BatchEncryptedMarginalPriceLot", id),
    );
  }

  static load(id: string): BatchEncryptedMarginalPriceLot | null {
    return changetype<BatchEncryptedMarginalPriceLot | null>(
      store.get("BatchEncryptedMarginalPriceLot", id),
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get status(): string {
    let value = this.get("status");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set status(value: string) {
    this.set("status", Value.fromString(value));
  }

  get minPrice(): BigDecimal {
    let value = this.get("minPrice");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set minPrice(value: BigDecimal) {
    this.set("minPrice", Value.fromBigDecimal(value));
  }

  get minFilled(): BigDecimal {
    let value = this.get("minFilled");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set minFilled(value: BigDecimal) {
    this.set("minFilled", Value.fromBigDecimal(value));
  }

  get minBidSize(): BigDecimal {
    let value = this.get("minBidSize");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigDecimal();
    }
  }

  set minBidSize(value: BigDecimal) {
    this.set("minBidSize", Value.fromBigDecimal(value));
  }

  get marginalPrice(): BigDecimal | null {
    let value = this.get("marginalPrice");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigDecimal();
    }
  }

  set marginalPrice(value: BigDecimal | null) {
    if (!value) {
      this.unset("marginalPrice");
    } else {
      this.set("marginalPrice", Value.fromBigDecimal(<BigDecimal>value));
    }
  }

  get hasPartialFill(): boolean {
    let value = this.get("hasPartialFill");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set hasPartialFill(value: boolean) {
    this.set("hasPartialFill", Value.fromBoolean(value));
  }

  get partialBidId(): BigInt | null {
    let value = this.get("partialBidId");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set partialBidId(value: BigInt | null) {
    if (!value) {
      this.unset("partialBidId");
    } else {
      this.set("partialBidId", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class BatchLinearVestingLot extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save BatchLinearVestingLot entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type BatchLinearVestingLot must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("BatchLinearVestingLot", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): BatchLinearVestingLot | null {
    return changetype<BatchLinearVestingLot | null>(
      store.get_in_block("BatchLinearVestingLot", id.toHexString()),
    );
  }

  static load(id: Bytes): BatchLinearVestingLot | null {
    return changetype<BatchLinearVestingLot | null>(
      store.get("BatchLinearVestingLot", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get lot(): string {
    let value = this.get("lot");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set lot(value: string) {
    this.set("lot", Value.fromString(value));
  }

  get startTimestamp(): BigInt {
    let value = this.get("startTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set startTimestamp(value: BigInt) {
    this.set("startTimestamp", Value.fromBigInt(value));
  }

  get startDate(): string {
    let value = this.get("startDate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set startDate(value: string) {
    this.set("startDate", Value.fromString(value));
  }

  get expiryTimestamp(): BigInt {
    let value = this.get("expiryTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set expiryTimestamp(value: BigInt) {
    this.set("expiryTimestamp", Value.fromBigInt(value));
  }

  get expiryDate(): string {
    let value = this.get("expiryDate");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set expiryDate(value: string) {
    this.set("expiryDate", Value.fromString(value));
  }
}

export class Token extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Token entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type Token must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("Token", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): Token | null {
    return changetype<Token | null>(
      store.get_in_block("Token", id.toHexString()),
    );
  }

  static load(id: Bytes): Token | null {
    return changetype<Token | null>(store.get("Token", id.toHexString()));
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get decimals(): i32 {
    let value = this.get("decimals");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set decimals(value: i32) {
    this.set("decimals", Value.fromI32(value));
  }

  get totalSupply(): BigInt {
    let value = this.get("totalSupply");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalSupply(value: BigInt) {
    this.set("totalSupply", Value.fromBigInt(value));
  }
}

export class AuctionHouseOwnershipTransferred extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AuctionHouseOwnershipTransferred entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AuctionHouseOwnershipTransferred must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set(
        "AuctionHouseOwnershipTransferred",
        id.toBytes().toHexString(),
        this,
      );
    }
  }

  static loadInBlock(id: Bytes): AuctionHouseOwnershipTransferred | null {
    return changetype<AuctionHouseOwnershipTransferred | null>(
      store.get_in_block("AuctionHouseOwnershipTransferred", id.toHexString()),
    );
  }

  static load(id: Bytes): AuctionHouseOwnershipTransferred | null {
    return changetype<AuctionHouseOwnershipTransferred | null>(
      store.get("AuctionHouseOwnershipTransferred", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auctionHouse(): Bytes {
    let value = this.get("auctionHouse");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auctionHouse(value: Bytes) {
    this.set("auctionHouse", Value.fromBytes(value));
  }

  get caller(): Bytes {
    let value = this.get("caller");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set caller(value: Bytes) {
    this.set("caller", Value.fromBytes(value));
  }

  get newOwner(): Bytes {
    let value = this.get("newOwner");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set newOwner(value: Bytes) {
    this.set("newOwner", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AuctionHouseModuleInstalled extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AuctionHouseModuleInstalled entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AuctionHouseModuleInstalled must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set(
        "AuctionHouseModuleInstalled",
        id.toBytes().toHexString(),
        this,
      );
    }
  }

  static loadInBlock(id: Bytes): AuctionHouseModuleInstalled | null {
    return changetype<AuctionHouseModuleInstalled | null>(
      store.get_in_block("AuctionHouseModuleInstalled", id.toHexString()),
    );
  }

  static load(id: Bytes): AuctionHouseModuleInstalled | null {
    return changetype<AuctionHouseModuleInstalled | null>(
      store.get("AuctionHouseModuleInstalled", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auctionHouse(): Bytes {
    let value = this.get("auctionHouse");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auctionHouse(value: Bytes) {
    this.set("auctionHouse", Value.fromBytes(value));
  }

  get keycode(): Bytes {
    let value = this.get("keycode");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set keycode(value: Bytes) {
    this.set("keycode", Value.fromBytes(value));
  }

  get version(): i32 {
    let value = this.get("version");
    if (!value || value.kind == ValueKind.NULL) {
      return 0;
    } else {
      return value.toI32();
    }
  }

  set version(value: i32) {
    this.set("version", Value.fromI32(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AuctionHouseModuleSunset extends Entity {
  constructor(id: Bytes) {
    super();
    this.set("id", Value.fromBytes(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save AuctionHouseModuleSunset entity without an ID",
    );
    if (id) {
      assert(
        id.kind == ValueKind.BYTES,
        `Entities of type AuctionHouseModuleSunset must have an ID of type Bytes but the id '${id.displayData()}' is of type ${id.displayKind()}`,
      );
      store.set("AuctionHouseModuleSunset", id.toBytes().toHexString(), this);
    }
  }

  static loadInBlock(id: Bytes): AuctionHouseModuleSunset | null {
    return changetype<AuctionHouseModuleSunset | null>(
      store.get_in_block("AuctionHouseModuleSunset", id.toHexString()),
    );
  }

  static load(id: Bytes): AuctionHouseModuleSunset | null {
    return changetype<AuctionHouseModuleSunset | null>(
      store.get("AuctionHouseModuleSunset", id.toHexString()),
    );
  }

  get id(): Bytes {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set id(value: Bytes) {
    this.set("id", Value.fromBytes(value));
  }

  get auctionHouse(): Bytes {
    let value = this.get("auctionHouse");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set auctionHouse(value: Bytes) {
    this.set("auctionHouse", Value.fromBytes(value));
  }

  get keycode(): Bytes {
    let value = this.get("keycode");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set keycode(value: Bytes) {
    this.set("keycode", Value.fromBytes(value));
  }

  get blockNumber(): BigInt {
    let value = this.get("blockNumber");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockNumber(value: BigInt) {
    this.set("blockNumber", Value.fromBigInt(value));
  }

  get blockTimestamp(): BigInt {
    let value = this.get("blockTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set blockTimestamp(value: BigInt) {
    this.set("blockTimestamp", Value.fromBigInt(value));
  }

  get date(): string {
    let value = this.get("date");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set date(value: string) {
    this.set("date", Value.fromString(value));
  }

  get transactionHash(): Bytes {
    let value = this.get("transactionHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set transactionHash(value: Bytes) {
    this.set("transactionHash", Value.fromBytes(value));
  }
}

export class AtomicAuctionCancelledLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AtomicAuctionCancelled[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AtomicAuctionCancelled[]>(value);
  }
}

export class AtomicAuctionCreatedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AtomicAuctionCreated[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AtomicAuctionCreated[]>(value);
  }
}

export class AtomicAuctionCuratedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AtomicAuctionCurated[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AtomicAuctionCurated[]>(value);
  }
}

export class AtomicPurchaseLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AtomicPurchase[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AtomicPurchase[]>(value);
  }
}

export class AtomicFixedPriceSaleLotLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AtomicFixedPriceSaleLot[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AtomicFixedPriceSaleLot[]>(value);
  }
}

export class AtomicLinearVestingLotLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): AtomicLinearVestingLot[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<AtomicLinearVestingLot[]>(value);
  }
}

export class BatchAuctionCancelledLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BatchAuctionCancelled[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BatchAuctionCancelled[]>(value);
  }
}

export class BatchAuctionCreatedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BatchAuctionCreated[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BatchAuctionCreated[]>(value);
  }
}

export class BatchAuctionCuratedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BatchAuctionCurated[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BatchAuctionCurated[]>(value);
  }
}

export class BatchAuctionSettledLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BatchAuctionSettled[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BatchAuctionSettled[]>(value);
  }
}

export class BatchAuctionAbortedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BatchAuctionAborted[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BatchAuctionAborted[]>(value);
  }
}

export class BatchBidLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BatchBid[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BatchBid[]>(value);
  }
}

export class BatchBidDecryptedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BatchBidDecrypted[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BatchBidDecrypted[]>(value);
  }
}

export class BatchBidClaimedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BatchBidClaimed[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BatchBidClaimed[]>(value);
  }
}

export class BatchBidRefundedLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BatchBidRefunded[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BatchBidRefunded[]>(value);
  }
}

export class BatchEncryptedMarginalPriceLotLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BatchEncryptedMarginalPriceLot[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BatchEncryptedMarginalPriceLot[]>(value);
  }
}

export class BatchLinearVestingLotLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): BatchLinearVestingLot[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<BatchLinearVestingLot[]>(value);
  }
}
