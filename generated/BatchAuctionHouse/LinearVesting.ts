// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt,
} from "@graphprotocol/graph-ts";

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this);
  }
}

export class Approval__Params {
  _event: Approval;

  constructor(event: Approval) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get spender(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get id(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class DerivativeCreated extends ethereum.Event {
  get params(): DerivativeCreated__Params {
    return new DerivativeCreated__Params(this);
  }
}

export class DerivativeCreated__Params {
  _event: DerivativeCreated;

  constructor(event: DerivativeCreated) {
    this._event = event;
  }

  get tokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get start(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get expiry(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get baseToken(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class OperatorSet extends ethereum.Event {
  get params(): OperatorSet__Params {
    return new OperatorSet__Params(this);
  }
}

export class OperatorSet__Params {
  _event: OperatorSet;

  constructor(event: OperatorSet) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get operator(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get approved(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class Redeemed extends ethereum.Event {
  get params(): Redeemed__Params {
    return new Redeemed__Params(this);
  }
}

export class Redeemed__Params {
  _event: Redeemed;

  constructor(event: Redeemed) {
    this._event = event;
  }

  get tokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get owner(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this);
  }
}

export class Transfer__Params {
  _event: Transfer;

  constructor(event: Transfer) {
    this._event = event;
  }

  get caller(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get from(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get id(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get amount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class Unwrapped extends ethereum.Event {
  get params(): Unwrapped__Params {
    return new Unwrapped__Params(this);
  }
}

export class Unwrapped__Params {
  _event: Unwrapped;

  constructor(event: Unwrapped) {
    this._event = event;
  }

  get tokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get owner(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get wrappedToken(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class Wrapped extends ethereum.Event {
  get params(): Wrapped__Params {
    return new Wrapped__Params(this);
  }
}

export class Wrapped__Params {
  _event: Wrapped;

  constructor(event: Wrapped) {
    this._event = event;
  }

  get tokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get owner(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get wrappedToken(): Address {
    return this._event.parameters[3].value.toAddress();
  }
}

export class WrappedDerivativeCreated extends ethereum.Event {
  get params(): WrappedDerivativeCreated__Params {
    return new WrappedDerivativeCreated__Params(this);
  }
}

export class WrappedDerivativeCreated__Params {
  _event: WrappedDerivativeCreated;

  constructor(event: WrappedDerivativeCreated) {
    this._event = event;
  }

  get tokenId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get wrappedToken(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class LinearVesting__deployResult {
  value0: BigInt;
  value1: Address;

  constructor(value0: BigInt, value1: Address) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    return map;
  }

  getTokenId_(): BigInt {
    return this.value0;
  }

  getWrappedAddress_(): Address {
    return this.value1;
  }
}

export class LinearVesting__getTokenMetadataResultValue0Struct extends ethereum.Tuple {
  get exists(): boolean {
    return this[0].toBoolean();
  }

  get wrapped(): Address {
    return this[1].toAddress();
  }

  get underlyingToken(): Address {
    return this[2].toAddress();
  }

  get data(): Bytes {
    return this[3].toBytes();
  }
}

export class LinearVesting__mintResult {
  value0: BigInt;
  value1: Address;
  value2: BigInt;

  constructor(value0: BigInt, value1: Address, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }

  getValue0(): BigInt {
    return this.value0;
  }

  getValue1(): Address {
    return this.value1;
  }

  getValue2(): BigInt {
    return this.value2;
  }
}

export class LinearVesting__mint1Result {
  value0: BigInt;
  value1: Address;
  value2: BigInt;

  constructor(value0: BigInt, value1: Address, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromUnsignedBigInt(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    return map;
  }

  getTokenId_(): BigInt {
    return this.value0;
  }

  getWrappedAddress_(): Address {
    return this.value1;
  }

  getAmountCreated_(): BigInt {
    return this.value2;
  }
}

export class LinearVesting__tokenMetadataResult {
  value0: boolean;
  value1: Address;
  value2: Address;
  value3: Bytes;

  constructor(
    value0: boolean,
    value1: Address,
    value2: Address,
    value3: Bytes,
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromBoolean(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    map.set("value2", ethereum.Value.fromAddress(this.value2));
    map.set("value3", ethereum.Value.fromBytes(this.value3));
    return map;
  }

  getExists(): boolean {
    return this.value0;
  }

  getWrapped(): Address {
    return this.value1;
  }

  getUnderlyingToken(): Address {
    return this.value2;
  }

  getData(): Bytes {
    return this.value3;
  }
}

export class LinearVesting extends ethereum.SmartContract {
  static bind(address: Address): LinearVesting {
    return new LinearVesting("LinearVesting", address);
  }

  PARENT(): Address {
    let result = super.call("PARENT", "PARENT():(address)", []);

    return result[0].toAddress();
  }

  try_PARENT(): ethereum.CallResult<Address> {
    let result = super.tryCall("PARENT", "PARENT():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  TYPE(): i32 {
    let result = super.call("TYPE", "TYPE():(uint8)", []);

    return result[0].toI32();
  }

  try_TYPE(): ethereum.CallResult<i32> {
    let result = super.tryCall("TYPE", "TYPE():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  VEECODE(): Bytes {
    let result = super.call("VEECODE", "VEECODE():(bytes7)", []);

    return result[0].toBytes();
  }

  try_VEECODE(): ethereum.CallResult<Bytes> {
    let result = super.tryCall("VEECODE", "VEECODE():(bytes7)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBytes());
  }

  allowance(param0: Address, param1: Address, param2: BigInt): BigInt {
    let result = super.call(
      "allowance",
      "allowance(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
      ],
    );

    return result[0].toBigInt();
  }

  try_allowance(
    param0: Address,
    param1: Address,
    param2: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "allowance",
      "allowance(address,address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  approve(param0: Address, param1: BigInt, param2: BigInt): boolean {
    let result = super.call(
      "approve",
      "approve(address,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
      ],
    );

    return result[0].toBoolean();
  }

  try_approve(
    param0: Address,
    param1: BigInt,
    param2: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "approve",
      "approve(address,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  balanceOf(param0: Address, param1: BigInt): BigInt {
    let result = super.call(
      "balanceOf",
      "balanceOf(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
      ],
    );

    return result[0].toBigInt();
  }

  try_balanceOf(param0: Address, param1: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "balanceOf",
      "balanceOf(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  computeId(underlyingToken_: Address, params_: Bytes): BigInt {
    let result = super.call("computeId", "computeId(address,bytes):(uint256)", [
      ethereum.Value.fromAddress(underlyingToken_),
      ethereum.Value.fromBytes(params_),
    ]);

    return result[0].toBigInt();
  }

  try_computeId(
    underlyingToken_: Address,
    params_: Bytes,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "computeId",
      "computeId(address,bytes):(uint256)",
      [
        ethereum.Value.fromAddress(underlyingToken_),
        ethereum.Value.fromBytes(params_),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  convertsTo(param0: Bytes, param1: BigInt): BigInt {
    let result = super.call(
      "convertsTo",
      "convertsTo(bytes,uint256):(uint256)",
      [
        ethereum.Value.fromBytes(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
      ],
    );

    return result[0].toBigInt();
  }

  try_convertsTo(param0: Bytes, param1: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "convertsTo",
      "convertsTo(bytes,uint256):(uint256)",
      [
        ethereum.Value.fromBytes(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  decimals(tokenId_: BigInt): i32 {
    let result = super.call("decimals", "decimals(uint256):(uint8)", [
      ethereum.Value.fromUnsignedBigInt(tokenId_),
    ]);

    return result[0].toI32();
  }

  try_decimals(tokenId_: BigInt): ethereum.CallResult<i32> {
    let result = super.tryCall("decimals", "decimals(uint256):(uint8)", [
      ethereum.Value.fromUnsignedBigInt(tokenId_),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  deploy(
    underlyingToken_: Address,
    params_: Bytes,
    wrapped_: boolean,
  ): LinearVesting__deployResult {
    let result = super.call(
      "deploy",
      "deploy(address,bytes,bool):(uint256,address)",
      [
        ethereum.Value.fromAddress(underlyingToken_),
        ethereum.Value.fromBytes(params_),
        ethereum.Value.fromBoolean(wrapped_),
      ],
    );

    return new LinearVesting__deployResult(
      result[0].toBigInt(),
      result[1].toAddress(),
    );
  }

  try_deploy(
    underlyingToken_: Address,
    params_: Bytes,
    wrapped_: boolean,
  ): ethereum.CallResult<LinearVesting__deployResult> {
    let result = super.tryCall(
      "deploy",
      "deploy(address,bytes,bool):(uint256,address)",
      [
        ethereum.Value.fromAddress(underlyingToken_),
        ethereum.Value.fromBytes(params_),
        ethereum.Value.fromBoolean(wrapped_),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LinearVesting__deployResult(
        value[0].toBigInt(),
        value[1].toAddress(),
      ),
    );
  }

  exerciseCost(param0: Bytes, param1: BigInt): BigInt {
    let result = super.call(
      "exerciseCost",
      "exerciseCost(bytes,uint256):(uint256)",
      [
        ethereum.Value.fromBytes(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
      ],
    );

    return result[0].toBigInt();
  }

  try_exerciseCost(param0: Bytes, param1: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "exerciseCost",
      "exerciseCost(bytes,uint256):(uint256)",
      [
        ethereum.Value.fromBytes(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTokenMetadata(
    tokenId: BigInt,
  ): LinearVesting__getTokenMetadataResultValue0Struct {
    let result = super.call(
      "getTokenMetadata",
      "getTokenMetadata(uint256):((bool,address,address,bytes))",
      [ethereum.Value.fromUnsignedBigInt(tokenId)],
    );

    return changetype<LinearVesting__getTokenMetadataResultValue0Struct>(
      result[0].toTuple(),
    );
  }

  try_getTokenMetadata(
    tokenId: BigInt,
  ): ethereum.CallResult<LinearVesting__getTokenMetadataResultValue0Struct> {
    let result = super.tryCall(
      "getTokenMetadata",
      "getTokenMetadata(uint256):((bool,address,address,bytes))",
      [ethereum.Value.fromUnsignedBigInt(tokenId)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<LinearVesting__getTokenMetadataResultValue0Struct>(
        value[0].toTuple(),
      ),
    );
  }

  isOperator(param0: Address, param1: Address): boolean {
    let result = super.call(
      "isOperator",
      "isOperator(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)],
    );

    return result[0].toBoolean();
  }

  try_isOperator(
    param0: Address,
    param1: Address,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isOperator",
      "isOperator(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  mint(
    to_: Address,
    tokenId_: BigInt,
    amount_: BigInt,
    wrapped_: boolean,
  ): LinearVesting__mintResult {
    let result = super.call(
      "mint",
      "mint(address,uint256,uint256,bool):(uint256,address,uint256)",
      [
        ethereum.Value.fromAddress(to_),
        ethereum.Value.fromUnsignedBigInt(tokenId_),
        ethereum.Value.fromUnsignedBigInt(amount_),
        ethereum.Value.fromBoolean(wrapped_),
      ],
    );

    return new LinearVesting__mintResult(
      result[0].toBigInt(),
      result[1].toAddress(),
      result[2].toBigInt(),
    );
  }

  try_mint(
    to_: Address,
    tokenId_: BigInt,
    amount_: BigInt,
    wrapped_: boolean,
  ): ethereum.CallResult<LinearVesting__mintResult> {
    let result = super.tryCall(
      "mint",
      "mint(address,uint256,uint256,bool):(uint256,address,uint256)",
      [
        ethereum.Value.fromAddress(to_),
        ethereum.Value.fromUnsignedBigInt(tokenId_),
        ethereum.Value.fromUnsignedBigInt(amount_),
        ethereum.Value.fromBoolean(wrapped_),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LinearVesting__mintResult(
        value[0].toBigInt(),
        value[1].toAddress(),
        value[2].toBigInt(),
      ),
    );
  }

  mint1(
    to_: Address,
    underlyingToken_: Address,
    params_: Bytes,
    amount_: BigInt,
    wrapped_: boolean,
  ): LinearVesting__mint1Result {
    let result = super.call(
      "mint",
      "mint(address,address,bytes,uint256,bool):(uint256,address,uint256)",
      [
        ethereum.Value.fromAddress(to_),
        ethereum.Value.fromAddress(underlyingToken_),
        ethereum.Value.fromBytes(params_),
        ethereum.Value.fromUnsignedBigInt(amount_),
        ethereum.Value.fromBoolean(wrapped_),
      ],
    );

    return new LinearVesting__mint1Result(
      result[0].toBigInt(),
      result[1].toAddress(),
      result[2].toBigInt(),
    );
  }

  try_mint1(
    to_: Address,
    underlyingToken_: Address,
    params_: Bytes,
    amount_: BigInt,
    wrapped_: boolean,
  ): ethereum.CallResult<LinearVesting__mint1Result> {
    let result = super.tryCall(
      "mint",
      "mint(address,address,bytes,uint256,bool):(uint256,address,uint256)",
      [
        ethereum.Value.fromAddress(to_),
        ethereum.Value.fromAddress(underlyingToken_),
        ethereum.Value.fromBytes(params_),
        ethereum.Value.fromUnsignedBigInt(amount_),
        ethereum.Value.fromBoolean(wrapped_),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LinearVesting__mint1Result(
        value[0].toBigInt(),
        value[1].toAddress(),
        value[2].toBigInt(),
      ),
    );
  }

  name(tokenId_: BigInt): string {
    let result = super.call("name", "name(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(tokenId_),
    ]);

    return result[0].toString();
  }

  try_name(tokenId_: BigInt): ethereum.CallResult<string> {
    let result = super.tryCall("name", "name(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(tokenId_),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  redeemable(owner_: Address, tokenId_: BigInt): BigInt {
    let result = super.call(
      "redeemable",
      "redeemable(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(owner_),
        ethereum.Value.fromUnsignedBigInt(tokenId_),
      ],
    );

    return result[0].toBigInt();
  }

  try_redeemable(
    owner_: Address,
    tokenId_: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "redeemable",
      "redeemable(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(owner_),
        ethereum.Value.fromUnsignedBigInt(tokenId_),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  setOperator(operator: Address, approved: boolean): boolean {
    let result = super.call("setOperator", "setOperator(address,bool):(bool)", [
      ethereum.Value.fromAddress(operator),
      ethereum.Value.fromBoolean(approved),
    ]);

    return result[0].toBoolean();
  }

  try_setOperator(
    operator: Address,
    approved: boolean,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "setOperator",
      "setOperator(address,bool):(bool)",
      [
        ethereum.Value.fromAddress(operator),
        ethereum.Value.fromBoolean(approved),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  supportsInterface(interfaceId: Bytes): boolean {
    let result = super.call(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)],
    );

    return result[0].toBoolean();
  }

  try_supportsInterface(interfaceId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  symbol(tokenId_: BigInt): string {
    let result = super.call("symbol", "symbol(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(tokenId_),
    ]);

    return result[0].toString();
  }

  try_symbol(tokenId_: BigInt): ethereum.CallResult<string> {
    let result = super.tryCall("symbol", "symbol(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(tokenId_),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  tokenMetadata(tokenId: BigInt): LinearVesting__tokenMetadataResult {
    let result = super.call(
      "tokenMetadata",
      "tokenMetadata(uint256):(bool,address,address,bytes)",
      [ethereum.Value.fromUnsignedBigInt(tokenId)],
    );

    return new LinearVesting__tokenMetadataResult(
      result[0].toBoolean(),
      result[1].toAddress(),
      result[2].toAddress(),
      result[3].toBytes(),
    );
  }

  try_tokenMetadata(
    tokenId: BigInt,
  ): ethereum.CallResult<LinearVesting__tokenMetadataResult> {
    let result = super.tryCall(
      "tokenMetadata",
      "tokenMetadata(uint256):(bool,address,address,bytes)",
      [ethereum.Value.fromUnsignedBigInt(tokenId)],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new LinearVesting__tokenMetadataResult(
        value[0].toBoolean(),
        value[1].toAddress(),
        value[2].toAddress(),
        value[3].toBytes(),
      ),
    );
  }

  transfer(param0: Address, param1: BigInt, param2: BigInt): boolean {
    let result = super.call(
      "transfer",
      "transfer(address,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
      ],
    );

    return result[0].toBoolean();
  }

  try_transfer(
    param0: Address,
    param1: BigInt,
    param2: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transfer",
      "transfer(address,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  transferFrom(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: BigInt,
  ): boolean {
    let result = super.call(
      "transferFrom",
      "transferFrom(address,address,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromUnsignedBigInt(param3),
      ],
    );

    return result[0].toBoolean();
  }

  try_transferFrom(
    param0: Address,
    param1: Address,
    param2: BigInt,
    param3: BigInt,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "transferFrom",
      "transferFrom(address,address,uint256,uint256):(bool)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromAddress(param1),
        ethereum.Value.fromUnsignedBigInt(param2),
        ethereum.Value.fromUnsignedBigInt(param3),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  userClaimed(owner_: Address, tokenId_: BigInt): BigInt {
    let result = super.call(
      "userClaimed",
      "userClaimed(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(owner_),
        ethereum.Value.fromUnsignedBigInt(tokenId_),
      ],
    );

    return result[0].toBigInt();
  }

  try_userClaimed(
    owner_: Address,
    tokenId_: BigInt,
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "userClaimed",
      "userClaimed(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(owner_),
        ethereum.Value.fromUnsignedBigInt(tokenId_),
      ],
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  validate(underlyingToken_: Address, params_: Bytes): boolean {
    let result = super.call("validate", "validate(address,bytes):(bool)", [
      ethereum.Value.fromAddress(underlyingToken_),
      ethereum.Value.fromBytes(params_),
    ]);

    return result[0].toBoolean();
  }

  try_validate(
    underlyingToken_: Address,
    params_: Bytes,
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall("validate", "validate(address,bytes):(bool)", [
      ethereum.Value.fromAddress(underlyingToken_),
      ethereum.Value.fromBytes(params_),
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get parent_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class INITCall extends ethereum.Call {
  get inputs(): INITCall__Inputs {
    return new INITCall__Inputs(this);
  }

  get outputs(): INITCall__Outputs {
    return new INITCall__Outputs(this);
  }
}

export class INITCall__Inputs {
  _call: INITCall;

  constructor(call: INITCall) {
    this._call = call;
  }
}

export class INITCall__Outputs {
  _call: INITCall;

  constructor(call: INITCall) {
    this._call = call;
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this);
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this);
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value1(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get value2(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall;

  constructor(call: ApproveCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class DeployCall extends ethereum.Call {
  get inputs(): DeployCall__Inputs {
    return new DeployCall__Inputs(this);
  }

  get outputs(): DeployCall__Outputs {
    return new DeployCall__Outputs(this);
  }
}

export class DeployCall__Inputs {
  _call: DeployCall;

  constructor(call: DeployCall) {
    this._call = call;
  }

  get underlyingToken_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get params_(): Bytes {
    return this._call.inputValues[1].value.toBytes();
  }

  get wrapped_(): boolean {
    return this._call.inputValues[2].value.toBoolean();
  }
}

export class DeployCall__Outputs {
  _call: DeployCall;

  constructor(call: DeployCall) {
    this._call = call;
  }

  get tokenId_(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get wrappedAddress_(): Address {
    return this._call.outputValues[1].value.toAddress();
  }
}

export class ExerciseCall extends ethereum.Call {
  get inputs(): ExerciseCall__Inputs {
    return new ExerciseCall__Inputs(this);
  }

  get outputs(): ExerciseCall__Outputs {
    return new ExerciseCall__Outputs(this);
  }
}

export class ExerciseCall__Inputs {
  _call: ExerciseCall;

  constructor(call: ExerciseCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get value1(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ExerciseCall__Outputs {
  _call: ExerciseCall;

  constructor(call: ExerciseCall) {
    this._call = call;
  }
}

export class MintCall extends ethereum.Call {
  get inputs(): MintCall__Inputs {
    return new MintCall__Inputs(this);
  }

  get outputs(): MintCall__Outputs {
    return new MintCall__Outputs(this);
  }
}

export class MintCall__Inputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }

  get to_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get tokenId_(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get amount_(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get wrapped_(): boolean {
    return this._call.inputValues[3].value.toBoolean();
  }
}

export class MintCall__Outputs {
  _call: MintCall;

  constructor(call: MintCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get value1(): Address {
    return this._call.outputValues[1].value.toAddress();
  }

  get value2(): BigInt {
    return this._call.outputValues[2].value.toBigInt();
  }
}

export class Mint1Call extends ethereum.Call {
  get inputs(): Mint1Call__Inputs {
    return new Mint1Call__Inputs(this);
  }

  get outputs(): Mint1Call__Outputs {
    return new Mint1Call__Outputs(this);
  }
}

export class Mint1Call__Inputs {
  _call: Mint1Call;

  constructor(call: Mint1Call) {
    this._call = call;
  }

  get to_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get underlyingToken_(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get params_(): Bytes {
    return this._call.inputValues[2].value.toBytes();
  }

  get amount_(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get wrapped_(): boolean {
    return this._call.inputValues[4].value.toBoolean();
  }
}

export class Mint1Call__Outputs {
  _call: Mint1Call;

  constructor(call: Mint1Call) {
    this._call = call;
  }

  get tokenId_(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get wrappedAddress_(): Address {
    return this._call.outputValues[1].value.toAddress();
  }

  get amountCreated_(): BigInt {
    return this._call.outputValues[2].value.toBigInt();
  }
}

export class ReclaimCall extends ethereum.Call {
  get inputs(): ReclaimCall__Inputs {
    return new ReclaimCall__Inputs(this);
  }

  get outputs(): ReclaimCall__Outputs {
    return new ReclaimCall__Outputs(this);
  }
}

export class ReclaimCall__Inputs {
  _call: ReclaimCall;

  constructor(call: ReclaimCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class ReclaimCall__Outputs {
  _call: ReclaimCall;

  constructor(call: ReclaimCall) {
    this._call = call;
  }
}

export class RedeemCall extends ethereum.Call {
  get inputs(): RedeemCall__Inputs {
    return new RedeemCall__Inputs(this);
  }

  get outputs(): RedeemCall__Outputs {
    return new RedeemCall__Outputs(this);
  }
}

export class RedeemCall__Inputs {
  _call: RedeemCall;

  constructor(call: RedeemCall) {
    this._call = call;
  }

  get tokenId_(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get amount_(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RedeemCall__Outputs {
  _call: RedeemCall;

  constructor(call: RedeemCall) {
    this._call = call;
  }
}

export class RedeemMaxCall extends ethereum.Call {
  get inputs(): RedeemMaxCall__Inputs {
    return new RedeemMaxCall__Inputs(this);
  }

  get outputs(): RedeemMaxCall__Outputs {
    return new RedeemMaxCall__Outputs(this);
  }
}

export class RedeemMaxCall__Inputs {
  _call: RedeemMaxCall;

  constructor(call: RedeemMaxCall) {
    this._call = call;
  }

  get tokenId_(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class RedeemMaxCall__Outputs {
  _call: RedeemMaxCall;

  constructor(call: RedeemMaxCall) {
    this._call = call;
  }
}

export class SetOperatorCall extends ethereum.Call {
  get inputs(): SetOperatorCall__Inputs {
    return new SetOperatorCall__Inputs(this);
  }

  get outputs(): SetOperatorCall__Outputs {
    return new SetOperatorCall__Outputs(this);
  }
}

export class SetOperatorCall__Inputs {
  _call: SetOperatorCall;

  constructor(call: SetOperatorCall) {
    this._call = call;
  }

  get operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get approved(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetOperatorCall__Outputs {
  _call: SetOperatorCall;

  constructor(call: SetOperatorCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this);
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this);
  }
}

export class TransferCall__Inputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value1(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }

  get value2(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransferCall__Outputs {
  _call: TransferCall;

  constructor(call: TransferCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this);
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this);
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get value0(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get value1(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get value2(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get value3(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall;

  constructor(call: TransferFromCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class TransformCall extends ethereum.Call {
  get inputs(): TransformCall__Inputs {
    return new TransformCall__Inputs(this);
  }

  get outputs(): TransformCall__Outputs {
    return new TransformCall__Outputs(this);
  }
}

export class TransformCall__Inputs {
  _call: TransformCall;

  constructor(call: TransformCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get value1(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get value2(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }
}

export class TransformCall__Outputs {
  _call: TransformCall;

  constructor(call: TransformCall) {
    this._call = call;
  }
}

export class UnwrapCall extends ethereum.Call {
  get inputs(): UnwrapCall__Inputs {
    return new UnwrapCall__Inputs(this);
  }

  get outputs(): UnwrapCall__Outputs {
    return new UnwrapCall__Outputs(this);
  }
}

export class UnwrapCall__Inputs {
  _call: UnwrapCall;

  constructor(call: UnwrapCall) {
    this._call = call;
  }

  get tokenId_(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get amount_(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class UnwrapCall__Outputs {
  _call: UnwrapCall;

  constructor(call: UnwrapCall) {
    this._call = call;
  }
}

export class WrapCall extends ethereum.Call {
  get inputs(): WrapCall__Inputs {
    return new WrapCall__Inputs(this);
  }

  get outputs(): WrapCall__Outputs {
    return new WrapCall__Outputs(this);
  }
}

export class WrapCall__Inputs {
  _call: WrapCall;

  constructor(call: WrapCall) {
    this._call = call;
  }

  get tokenId_(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get amount_(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class WrapCall__Outputs {
  _call: WrapCall;

  constructor(call: WrapCall) {
    this._call = call;
  }
}
